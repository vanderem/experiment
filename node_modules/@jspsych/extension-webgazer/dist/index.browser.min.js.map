{"version":3,"file":"index.browser.min.js","sources":["../package.json","../src/index.ts"],"sourcesContent":["{\n  \"name\": \"@jspsych/extension-webgazer\",\n  \"version\": \"1.2.0\",\n  \"description\": \"jsPsych extension for eye tracking using WebGazer.js\",\n  \"type\": \"module\",\n  \"main\": \"dist/index.cjs\",\n  \"exports\": {\n    \"import\": \"./dist/index.js\",\n    \"require\": \"./dist/index.cjs\"\n  },\n  \"typings\": \"dist/index.d.ts\",\n  \"unpkg\": \"dist/index.browser.min.js\",\n  \"files\": [\n    \"src\",\n    \"dist\"\n  ],\n  \"source\": \"src/index.ts\",\n  \"scripts\": {\n    \"test\": \"jest --passWithNoTests\",\n    \"test:watch\": \"npm test -- --watch\",\n    \"tsc\": \"tsc\",\n    \"build\": \"rollup --config\",\n    \"build:watch\": \"npm run build -- --watch\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/jspsych/jsPsych.git\",\n    \"directory\": \"packages/extension-webgazer\"\n  },\n  \"author\": \"Josh de Leeuw\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/jspsych/jsPsych/issues\"\n  },\n  \"homepage\": \"https://www.jspsych.org/latest/extensions/webgazer\",\n  \"peerDependencies\": {\n    \"jspsych\": \">=7.0.0\"\n  },\n  \"devDependencies\": {\n    \"@jspsych/config\": \"^3.2.0\",\n    \"@jspsych/test-utils\": \"^1.2.0\"\n  }\n}\n","import { JsPsych, JsPsychExtension, JsPsychExtensionInfo, ParameterType } from \"jspsych\";\n\nimport { version } from \"../package.json\";\n\n// we have to add webgazer to the global window object because webgazer attaches itself to\n// the window when it loads\ndeclare global {\n  interface Window {\n    webgazer: any;\n  }\n}\n\ninterface InitializeParameters {\n  /**\n   * Whether to round WebGazer's predicted x, y coordinates to the nearest integer. Recommended\n   * to leave this as `true` because it saves significant space in the data object and the\n   * predictions aren't precise to the level of partial pixels.\n   * @default true\n   */\n  round_predictions: boolean;\n  /**\n   * Whether to initialize WebGazer automatically when the plugin loads. Leave this as `false`\n   * if you plan to initialize WebGazer later in the experiment using a plugin.\n   * @default false\n   */\n  auto_initialize: boolean;\n  /**\n   * The number of milliseconds between each sample. Note that this is only a request, and the\n   * actual interval will vary depending on processing time.\n   * @default 34\n   */\n  sampling_interval: number;\n  /**\n   * An instance of WebGazer. If left undefined then the global window.webgazer object will be used\n   * if it exists.\n   */\n  webgazer: any;\n}\n\ninterface OnStartParameters {\n  targets: Array<string>;\n}\n\n/**\n * https://www.jspsych.org/latest/extensions/webgazer/\n */\nclass WebGazerExtension implements JsPsychExtension {\n  static info: JsPsychExtensionInfo = {\n    name: \"webgazer\",\n    version: version,\n    data: {\n      /** An array of objects containing gaze data for the trial. Each object has an `x`, a `y`, and a `t` property. The `x` and\n       * `y` properties specify the gaze location in pixels and `t` specifies the time in milliseconds since the start of the trial.\n       */\n      webgazer_data: {\n        type: ParameterType.INT,\n        array: true,\n      },\n      /** An object contain the pixel coordinates of elements on the screen specified by the `.targets` parameter. Each key in this\n       * object will be a `selector` property, containing the CSS selector string used to find the element. The object corresponding\n       * to each key will contain `x` and `y` properties specifying the top-left corner of the object, `width` and `height` values,\n       * plus `top`, `bottom`, `left`, and `right` parameters which specify the [bounding rectangle](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect) of the element.\n       */\n      webgazer_targets: {\n        type: ParameterType.COMPLEX,\n        nested: {\n          x: {\n            type: ParameterType.INT,\n          },\n          y: {\n            type: ParameterType.INT,\n          },\n          width: {\n            type: ParameterType.INT,\n          },\n          height: {\n            type: ParameterType.INT,\n          },\n          top: {\n            type: ParameterType.INT,\n          },\n          bottom: {\n            type: ParameterType.INT,\n          },\n          left: {\n            type: ParameterType.INT,\n          },\n          right: {\n            type: ParameterType.INT,\n          },\n        },\n      },\n    },\n    // prettier-ignore\n    citations: '__CITATIONS__',\n  };\n\n  constructor(private jsPsych: JsPsych) {}\n\n  // private state for the extension\n  // extension authors can define public functions to interact\n  // with the state. recommend not exposing state directly\n  // so that state manipulations are checked.\n  private currentTrialData = [];\n  private currentTrialTargets = {};\n  private currentTrialSelectors: Array<string>;\n  private domObserver: MutationObserver;\n  private webgazer;\n  private initialized = false;\n  private currentTrialStart: number;\n  private activeTrial = false;\n  private sampling_interval: number;\n  private round_predictions: boolean;\n  private gazeInterval: ReturnType<typeof setInterval>;\n  private gazeUpdateCallbacks: Array<any>;\n  private currentGaze: Object;\n\n  initialize = ({\n    round_predictions = true,\n    auto_initialize = false,\n    sampling_interval = 34,\n    webgazer,\n  }: InitializeParameters): Promise<void> => {\n    // set initial state of the extension\n    this.round_predictions = round_predictions;\n    this.sampling_interval = sampling_interval;\n    this.gazeUpdateCallbacks = [];\n    this.domObserver = new MutationObserver(this.mutationObserverCallback);\n\n    return new Promise((resolve, reject) => {\n      if (typeof webgazer === \"undefined\") {\n        if (window.webgazer) {\n          this.webgazer = window.webgazer;\n        } else {\n          reject(\n            new Error(\n              \"Webgazer extension failed to initialize. webgazer.js not loaded. Load webgazer.js before calling initJsPsych()\"\n            )\n          );\n        }\n      } else {\n        this.webgazer = webgazer;\n      }\n\n      // sets up event handler for webgazer data\n      // this.webgazer.setGazeListener(this.handleGazeDataUpdate);\n\n      // default to threadedRidge regression\n      // NEVER MIND... kalman filter is too useful.\n      //state.webgazer.workerScriptURL = 'js/webgazer/ridgeWorker.mjs';\n      //state.webgazer.setRegression('threadedRidge');\n      //state.webgazer.applyKalmanFilter(false); // kalman filter doesn't seem to work yet with threadedridge.\n\n      // hide video by default\n      this.hideVideo();\n\n      // hide predictions by default\n      this.hidePredictions();\n\n      if (auto_initialize) {\n        // starts webgazer, and once it initializes we stop mouseCalibration and\n        // pause webgazer data.\n        this.webgazer\n          .begin()\n          .then(() => {\n            this.initialized = true;\n            this.stopMouseCalibration();\n            this.pause();\n            resolve();\n          })\n          .catch((error) => {\n            console.error(error);\n            reject(error);\n          });\n      } else {\n        resolve();\n      }\n    });\n  };\n\n  on_start = (params: OnStartParameters): void => {\n    this.currentTrialData = [];\n    this.currentTrialTargets = {};\n    this.currentTrialSelectors = params.targets;\n\n    this.domObserver.observe(this.jsPsych.getDisplayElement(), { childList: true });\n  };\n\n  on_load = () => {\n    // set current trial start time\n    this.currentTrialStart = performance.now();\n\n    // resume data collection\n    // state.webgazer.resume();\n\n    this.startSampleInterval();\n\n    // set internal flag\n    this.activeTrial = true;\n  };\n\n  on_finish = () => {\n    // pause the eye tracker\n    this.stopSampleInterval();\n\n    // stop watching the DOM\n    this.domObserver.disconnect();\n\n    // state.webgazer.pause();\n\n    // set internal flag\n    this.activeTrial = false;\n\n    // send back the gazeData\n    return {\n      webgazer_data: this.currentTrialData,\n      webgazer_targets: this.currentTrialTargets,\n    };\n  };\n\n  start = () => {\n    return new Promise<void>((resolve, reject) => {\n      if (typeof this.webgazer == \"undefined\") {\n        const error =\n          \"Failed to start webgazer. Things to check: Is webgazer.js loaded? Is the webgazer extension included in initJsPsych?\";\n        console.error(error);\n        reject(error);\n      }\n      this.webgazer\n        .begin()\n        .then(() => {\n          this.initialized = true;\n          this.stopMouseCalibration();\n          this.pause();\n          resolve();\n        })\n        .catch((error) => {\n          console.error(error);\n          reject(error);\n        });\n    });\n  };\n\n  startSampleInterval = (interval: number = this.sampling_interval) => {\n    this.gazeInterval = setInterval(() => {\n      this.webgazer.getCurrentPrediction().then(this.handleGazeDataUpdate);\n    }, interval);\n    // repeat the call here so that we get one immediate execution. above will not\n    // start until state.sampling_interval is reached the first time.\n    this.webgazer.getCurrentPrediction().then(this.handleGazeDataUpdate);\n  };\n\n  stopSampleInterval = () => {\n    clearInterval(this.gazeInterval);\n  };\n\n  isInitialized = () => {\n    return this.initialized;\n  };\n\n  faceDetected = () => {\n    return this.webgazer.getTracker().predictionReady;\n  };\n\n  showPredictions = () => {\n    this.webgazer.showPredictionPoints(true);\n  };\n\n  hidePredictions = () => {\n    this.webgazer.showPredictionPoints(false);\n  };\n\n  showVideo = () => {\n    this.webgazer.showVideo(true);\n    this.webgazer.showFaceOverlay(true);\n    this.webgazer.showFaceFeedbackBox(true);\n  };\n\n  hideVideo = () => {\n    this.webgazer.showVideo(false);\n    this.webgazer.showFaceOverlay(false);\n    this.webgazer.showFaceFeedbackBox(false);\n  };\n\n  resume = () => {\n    this.webgazer.resume();\n  };\n\n  pause = () => {\n    this.webgazer.pause();\n    // sometimes gaze dot will show and freeze after pause?\n    if (document.querySelector(\"#webgazerGazeDot\")) {\n      document.querySelector<HTMLElement>(\"#webgazerGazeDot\").style.display = \"none\";\n    }\n  };\n\n  resetCalibration = () => {\n    this.webgazer.clearData();\n  };\n\n  stopMouseCalibration = () => {\n    this.webgazer.removeMouseEventListeners();\n  };\n\n  startMouseCalibration = () => {\n    this.webgazer.addMouseEventListeners();\n  };\n\n  calibratePoint = (x: number, y: number) => {\n    this.webgazer.recordScreenPosition(x, y, \"click\");\n  };\n\n  setRegressionType = (regression_type) => {\n    var valid_regression_models = [\"ridge\", \"weightedRidge\", \"threadedRidge\"];\n    if (valid_regression_models.includes(regression_type)) {\n      this.webgazer.setRegression(regression_type);\n    } else {\n      console.warn(\n        \"Invalid regression_type parameter for webgazer.setRegressionType. Valid options are ridge, weightedRidge, and threadedRidge.\"\n      );\n    }\n  };\n\n  getCurrentPrediction = () => {\n    return this.webgazer.getCurrentPrediction();\n  };\n\n  onGazeUpdate = (callback) => {\n    this.gazeUpdateCallbacks.push(callback);\n    return () => {\n      this.gazeUpdateCallbacks = this.gazeUpdateCallbacks.filter((item) => {\n        return item !== callback;\n      });\n    };\n  };\n\n  private handleGazeDataUpdate = (gazeData, elapsedTime) => {\n    if (gazeData !== null) {\n      var d = {\n        x: this.round_predictions ? Math.round(gazeData.x) : gazeData.x,\n        y: this.round_predictions ? Math.round(gazeData.y) : gazeData.y,\n        t: gazeData.t,\n      };\n      if (this.activeTrial) {\n        //console.log(`handleUpdate: t = ${Math.round(gazeData.t)}, now = ${Math.round(performance.now())}`);\n        d.t = Math.round(gazeData.t - this.currentTrialStart);\n        this.currentTrialData.push(d); // add data to current trial's data\n      }\n      this.currentGaze = d;\n      for (var i = 0; i < this.gazeUpdateCallbacks.length; i++) {\n        this.gazeUpdateCallbacks[i](d);\n      }\n    } else {\n      this.currentGaze = null;\n    }\n  };\n\n  private mutationObserverCallback = (mutationsList, observer) => {\n    for (const selector of this.currentTrialSelectors) {\n      if (!this.currentTrialTargets[selector]) {\n        if (this.jsPsych.getDisplayElement().querySelector(selector)) {\n          var coords = this.jsPsych\n            .getDisplayElement()\n            .querySelector(selector)\n            .getBoundingClientRect();\n          this.currentTrialTargets[selector] = coords;\n        }\n      }\n    }\n  };\n}\n\nexport default WebGazerExtension;\n"],"names":["version"],"mappings":"sDAEEA,IAAAA,EAAW,6xIC4FE,UAAA,iuBAAe"}